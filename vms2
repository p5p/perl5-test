From sugalskd@osshe.edu  Thu Oct 23 23:04:17 1997
Received: from oxmail4.ox.ac.uk (oxmail4.ox.ac.uk [163.1.2.33]) by sable.ox.ac.uk (1.2/8.8.3) with SMTP id XAA08805 for <mbeattie@sable.ox.ac.uk>; Thu, 23 Oct 1997 23:04:16 +0100 (BST)
Received: from osshe.edu by oxmail4 with SMTP (PP) with ESMTP;
          Thu, 23 Oct 1997 23:04:12 +0100
Received: from beech.conet.osshe.edu (southbeach.CONET.OSSHE.EDU [140.211.15.50])	by osshe.edu (8.8.7/8.8.7) 
          with SMTP id PAA21545;	Thu, 23 Oct 1997 15:03:59 -0700 (PDT)
Message-Id: <3.0.3.32.19971023150355.02f27484@osshe.edu>
X-Sender: sugalskd@osshe.edu
X-Mailer: QUALCOMM Windows Eudora Light Version 3.0.3 (32)
Date: Thu, 23 Oct 1997 15:03:55 -0700
To: perl5-porters@perl.org, vmsperl@cor.newman.upenn.edu,
        mbeattie@sable.ox.ac.uk
From: Dan Sugalski <sugalskd@osshe.edu>
Subject: [PATCH][Perl5.004_53] Patches to get 5.004_53 working with VMS  6.2
Mime-Version: 1.0
Content-Type: text/plain; charset="us-ascii"
Status: RO

The following patches are required to get 5.004_53 compiling on VMS 6.2. (Okay,
they aren't needed if you're not using threads, but then what's the point?)
The quick description for the changes is:

ext/thread/thread.xs:
Fixup for OLD_PTHREADS_API issue, and changed ssize_t to SSize_t.

thread.h:
Fixup for OLD_PTHREADS_API issue

vms/descrip.mms:
Now has options to compile with thread support, and make the Attrs and Thread
modules, if appropriate.

vms/gen_shrfls.pl:
Changed to pick up more symbols to be exported

vms/vms.c,vms/vmsish.h,ext/posix/posix.xs:
Moved signal emulation routines (for VMS 6.2 and below) from posix.xs to vms.c
for threading use.


Note that these two lines:

SYMBOL_VECTOR=(Perl_runops=DATA)
SYMBOL_VECTOR=(getTHR=PROCEDURE)

need to be added to PERLSHR_BLD.OPT after it's created. The build will die
with a link error, at which point these lines should be added, PERL.EXE and
PERLSHR.EXE deleted, and the build resumed.

To build with threads (which is *not* the default), a /Macro="THREADED=1"
needs to be added to build with 'real' Posix threads (vms 7.0 and up),
/Macro="OLDTHREADED=1" for draft Posix threads (VMS 6.2 and below),
or /Macro="FAKETHREADED=1" to build with fake threads which don't
work yet. :)

Selection of draft or release Posix threads ought to be automatic,
but it's not yet.


Index: ext/thread/thread.xs
**************
*** 199,205
      Thread savethread;
      int i;
      SV *sv;
!     sigset_t fullmask, oldmask;
      
      savethread = thr;
      sv = newSVpv("", 0);
--- 199,206 -----
      Thread savethread;
      int i;
      SV *sv;
!     sigset_t fullmask;
!     sigset_t oldmask;
      
      savethread = thr;
      sv = newSVpv("", 0);
**************
*** 256,261
      sigfillset(&fullmask);
      if (sigprocmask(SIG_SETMASK, &fullmask, &oldmask) == -1)
  	croak("panic: sigprocmask");
      if (pthread_create(&self, NULL, threadstart, (void*) thr))
  	return NULL;	/* XXX should clean up first */
      /* Go */
--- 257,265 -----
      sigfillset(&fullmask);
      if (sigprocmask(SIG_SETMASK, &fullmask, &oldmask) == -1)
  	croak("panic: sigprocmask");
+ #ifdef OLD_PTHREADS_API
+     if (pthread_create(&self, pthread_attr_default, threadstart, (void*) thr))
+ #else
      if (pthread_create(&self, NULL, threadstart, (void*) thr))
  #endif
  	return NULL;	/* XXX should clean up first */
**************
*** 257,262
      if (sigprocmask(SIG_SETMASK, &fullmask, &oldmask) == -1)
  	croak("panic: sigprocmask");
      if (pthread_create(&self, NULL, threadstart, (void*) thr))
  	return NULL;	/* XXX should clean up first */
      /* Go */
      MUTEX_UNLOCK(&thr->mutex);
--- 261,267 -----
      if (pthread_create(&self, pthread_attr_default, threadstart, (void*) thr))
  #else
      if (pthread_create(&self, NULL, threadstart, (void*) thr))
+ #endif
  	return NULL;	/* XXX should clean up first */
      /* Go */
      MUTEX_UNLOCK(&thr->mutex);
**************
*** 536,542
  await_signal()
      PREINIT:
  	char c;
! 	ssize_t ret;
      CODE:
  	do {
  	    ret = read(sig_pipe[1], &c, 1);
--- 541,547 -----
  await_signal()
      PREINIT:
  	char c;
! 	SSize_t ret;
      CODE:
  	do {
  	    ret = read(sig_pipe[1], &c, 1);



Index: thread.h
**************
*** 74,79
      if (pthread_cond_destroy((c))) croak("panic: COND_DESTROY"); else 1
  
  /* DETACH(t) must only be called while holding t->mutex */
  #define DETACH(t)			\
      if (pthread_detach((t)->Tself)) {	\
  	MUTEX_UNLOCK(&(t)->mutex);	\
--- 74,80 -----
      if (pthread_cond_destroy((c))) croak("panic: COND_DESTROY"); else 1
  
  /* DETACH(t) must only be called while holding t->mutex */
+ #ifdef OLD_PTHREADS_API
  #define DETACH(t)			\
      if (pthread_detach(&(t)->Tself)) {	\
  	MUTEX_UNLOCK(&(t)->mutex);	\
**************
*** 75,81
  
  /* DETACH(t) must only be called while holding t->mutex */
  #define DETACH(t)			\
!     if (pthread_detach((t)->Tself)) {	\
  	MUTEX_UNLOCK(&(t)->mutex);	\
  	croak("panic: DETACH");		\
      } else 1
--- 76,82 -----
  /* DETACH(t) must only be called while holding t->mutex */
  #ifdef OLD_PTHREADS_API
  #define DETACH(t)			\
!     if (pthread_detach(&(t)->Tself)) {	\
  	MUTEX_UNLOCK(&(t)->mutex);	\
  	croak("panic: DETACH");		\
      } else 1
**************
*** 79,84
  	MUTEX_UNLOCK(&(t)->mutex);	\
  	croak("panic: DETACH");		\
      } else 1
  
  /* XXX Add "old" (?) POSIX draft interface too */
  #ifdef OLD_PTHREADS_API
--- 80,92 -----
  	MUTEX_UNLOCK(&(t)->mutex);	\
  	croak("panic: DETACH");		\
      } else 1
+ #else
+ #define DETACH(t)			\
+     if (pthread_detach((t)->Tself)) {	\
+ 	MUTEX_UNLOCK(&(t)->mutex);	\
+ 	croak("panic: DETACH");		\
+     } else 1
+ #endif
  
  /* XXX Add "old" (?) POSIX draft interface too */
  #ifdef OLD_PTHREADS_API



Index: vms/descrip.mms
**************
*** 28,33
  #:                           SOCKETSHR socket support.
  #:                           /Macro="DECC_SOCKETS=1" to include UCX (or
  #:                           compatible) socket support
  #
  #	tidy      -- purge files generated by executing this file
  #	clean     -- remove all intermediate (e.g. object files, C files generated
--- 28,39 -----
  #:                           SOCKETSHR socket support.
  #:                           /Macro="DECC_SOCKETS=1" to include UCX (or
  #:                           compatible) socket support
+ #:			     /Macro="OLDTHREADED=1" to compile with the old
+ #:			     pthreads API (VMS version 6.2 and previous)
+ #:                           /Macro="THREADED=1" to compile with full POSIX
+ #:                           threads. (VMS 7.0 and above)
+ #:                           /Macro="FAKETHREADED=1" to compile with the
+ #:                           fake threads package
  #
  #	tidy      -- purge files generated by executing this file
  #	clean     -- remove all intermediate (e.g. object files, C files generated
**************
*** 202,207
  SOCKPM =
  .endif
  
  # C preprocessor manifest "DEBUGGING" ==> perl -D, not the VMS debugger
  CFLAGS = /Define=(DEBUGGING$(SOCKDEF)$(XTRADEF))$(XTRACCFLAGS)$(DBGCCFLAGS)
  LINKFLAGS = $(DBGLINKFLAGS)
--- 208,238 -----
  SOCKPM =
  .endif
  
+ THREADH = 
+ THREAD = 
+ 
+ .ifdef THREADED
+ THREADDEF = ,USE_THREADS,MULTIPLICITY
+ THREADH = thread.h
+ THREAD = THREAD
+ .endif
+ 
+ .ifdef OLDTHREADED
+ THREADDEF = ,USE_THREADS,MULTIPLICITY,OLD_PTHREADS_API
+ THREADH = thread.h
+ THREAD = THREAD
+ LIBS2 = sys$share:cma$lib_shr/share,cma$rtl/share
+ .ifdef __AXP__
+ LIBS2 = $(LIBS2),sys$share:cma$open_lib_shr/share,cma$open_rtl/share
+ .endif
+ .endif
+ 
+ .ifdef FAKETHREADED
+ THREADDEF = ,USE_THREADS,MULTIPLICITY,FAKE_THREADS
+ THREADH = thread.h fakethr.h
+ THREAD = THREAD
+ .endif
+ 
  # C preprocessor manifest "DEBUGGING" ==> perl -D, not the VMS debugger
  CFLAGS = /Define=(DEBUGGING$(SOCKDEF)$(XTRADEF)$(THREADDEF))$(XTRACCFLAGS)$(DBGCCFLAGS)
  LINKFLAGS = $(DBGLINKFLAGS)
**************
*** 203,209
  .endif
  
  # C preprocessor manifest "DEBUGGING" ==> perl -D, not the VMS debugger
! CFLAGS = /Define=(DEBUGGING$(SOCKDEF)$(XTRADEF))$(XTRACCFLAGS)$(DBGCCFLAGS)
  LINKFLAGS = $(DBGLINKFLAGS)
  
  MAKE = $(MMS)
--- 234,240 -----
  .endif
  
  # C preprocessor manifest "DEBUGGING" ==> perl -D, not the VMS debugger
! CFLAGS = /Define=(DEBUGGING$(SOCKDEF)$(XTRADEF)$(THREADDEF))$(XTRACCFLAGS)$(DBGCCFLAGS)
  LINKFLAGS = $(DBGLINKFLAGS)
  
  MAKE = $(MMS)
**************
*** 246,252
  h2 = embed.h, form.h, gv.h, handy.h, hv.h, keywords.h, mg.h, op.h
  h3 = opcode.h, patchlevel.h, perl.h, perly.h, pp.h, proto.h, regcomp.h
  h4 = regexp.h, scope.h, sv.h, vmsish.h, util.h, perlio.h, perlsdio.h
! h = $(h1), $(h2), $(h3), $(h4) $(SOCKHLIS)
  
  c1 = av.c, scope.c, op.c, doop.c, doio.c, dump.c, hv.c, mg.c, universal.c, perlio.c
  c2 = perl.c, perly.c, pp.c, pp_hot.c, pp_ctl.c, pp_sys.c, regcomp.c, regexec.c
--- 277,283 -----
  h2 = embed.h, form.h, gv.h, handy.h, hv.h, keywords.h, mg.h, op.h
  h3 = opcode.h, patchlevel.h, perl.h, perly.h, pp.h, proto.h, regcomp.h
  h4 = regexp.h, scope.h, sv.h, vmsish.h, util.h, perlio.h, perlsdio.h
! h = $(h1), $(h2), $(h3), $(h4) $(SOCKHLIS) $(THREADH)
  
  c1 = av.c, scope.c, op.c, doop.c, doio.c, dump.c, hv.c, mg.c, universal.c, perlio.c
  c2 = perl.c, perly.c, pp.c, pp_hot.c, pp_ctl.c, pp_sys.c, regcomp.c, regexec.c
**************
*** 311,317
  .endif
  base : miniperl perl
  	@ $(NOOP)
! extras : Fcntl IO Opcode $(POSIX) libmods utils podxform
  	@ $(NOOP)
  libmods : $(LIBPREREQ)
  	@ $(NOOP)
--- 342,348 -----
  .endif
  base : miniperl perl
  	@ $(NOOP)
! extras : Fcntl IO Opcode Attrs $(POSIX) $(THREAD) libmods utils podxform
  	@ $(NOOP)
  libmods : $(LIBPREREQ)
  	@ $(NOOP)
**************
*** 466,472
  [.ext.Fcntl]Descrip.MMS : [.ext.Fcntl]Makefile.PL $(LIBPREREQ) $(DBG)perlshr$(E)
  	$(MINIPERL) "-I[--.lib]" -e "chdir('[.ext.Fcntl]') or die $!; do 'Makefile.PL'; print ${@} if ${@};" "INST_LIB=[--.lib]" "INST_ARCHLIB=[--.lib]"
  
! POSIX : [.lib]POSIX.pm [.lib.auto.POSIX]POSIX$(E)
  	@ $(NOOP)
  
  [.lib]POSIX.pm : [.ext.POSIX]Descrip.MMS
--- 497,503 -----
  [.ext.Fcntl]Descrip.MMS : [.ext.Fcntl]Makefile.PL $(LIBPREREQ) $(DBG)perlshr$(E)
  	$(MINIPERL) "-I[--.lib]" -e "chdir('[.ext.Fcntl]') or die $!; do 'Makefile.PL'; print ${@} if ${@};" "INST_LIB=[--.lib]" "INST_ARCHLIB=[--.lib]"
  
! Attrs : [.lib]Attrs.pm [.lib.auto.Attrs]Attrs$(E)
  	@ $(NOOP)
  
  [.lib]Attrs.pm : [.ext.Attrs]Descrip.MMS
**************
*** 469,474
  POSIX : [.lib]POSIX.pm [.lib.auto.POSIX]POSIX$(E)
  	@ $(NOOP)
  
  [.lib]POSIX.pm : [.ext.POSIX]Descrip.MMS
  	@ If F$Search("[.lib]auto.dir").eqs."" Then Create/Directory [.lib.auto]
  	@ Set Default [.ext.POSIX]
--- 500,524 -----
  Attrs : [.lib]Attrs.pm [.lib.auto.Attrs]Attrs$(E)
  	@ $(NOOP)
  
+ [.lib]Attrs.pm : [.ext.Attrs]Descrip.MMS
+ 	@ If F$Search("[.lib]auto.dir").eqs."" Then Create/Directory [.lib.auto]
+ 	@ Set Default [.ext.Attrs]
+ 	$(MMS)
+ 	@ Set Default [--]
+ 
+ [.lib.auto.Attrs]Attrs$(E) : [.ext.Attrs]Descrip.MMS
+ 	@ Set Default [.ext.Attrs]
+ 	$(MMS)
+ 	@ Set Default [--]
+ 
+ # Add "-I[--.lib]" t $(MINIPERL) so we use this copy of lib after C<chdir>
+ # ${@} necessary to distract different versions of MM[SK]/make
+ [.ext.Attrs]Descrip.MMS : [.ext.Fcntl]Makefile.PL $(LIBPREREQ) $(DBG)perlshr$(E)
+ 	$(MINIPERL) "-I[--.lib]" -e "chdir('[.ext.Attrs]') or die $!; do 'Makefile.PL'; print ${@} if ${@};" "INST_LIB=[--.lib]" "INST_ARCHLIB=[--.lib]"
+ 
+ POSIX : [.lib]POSIX.pm [.lib.auto.POSIX]POSIX$(E)
+ 	@ $(NOOP)
+ 
  [.lib]POSIX.pm : [.ext.POSIX]Descrip.MMS
  	@ If F$Search("[.lib]auto.dir").eqs."" Then Create/Directory [.lib.auto]
  	@ Set Default [.ext.POSIX]
**************
*** 485,491
  [.ext.POSIX]Descrip.MMS : [.ext.POSIX]Makefile.PL $(LIBPREREQ) $(DBG)perlshr$(E)
  	$(MINIPERL) "-I[--.lib]" -e "chdir('[.ext.POSIX]') or die $!; do 'Makefile.PL'; print ${@} if ${@};" "INST_LIB=[--.lib]" "INST_ARCHLIB=[--.lib]"
  
! IO : [.lib]IO.pm [.lib.IO]File.pm [.lib.IO]Handle.pm [.lib.IO]Pipe.pm [.lib.IO]Seekable.pm [.lib.IO]Socket.pm [.lib.auto.IO]IO$(E)
  	@ $(NOOP)
  
  [.lib]IO.pm : [.ext.IO]Descrip.MMS
--- 535,541 -----
  [.ext.POSIX]Descrip.MMS : [.ext.POSIX]Makefile.PL $(LIBPREREQ) $(DBG)perlshr$(E)
  	$(MINIPERL) "-I[--.lib]" -e "chdir('[.ext.POSIX]') or die $!; do 'Makefile.PL'; print ${@} if ${@};" "INST_LIB=[--.lib]" "INST_ARCHLIB=[--.lib]"
  
! THREAD : [.lib]THREAD.pm [.lib.auto.THREAD]THREAD$(E)
  	@ $(NOOP)
  
  [.lib]THREAD.pm : [.ext.THREAD]Descrip.MMS
**************
*** 488,493
  IO : [.lib]IO.pm [.lib.IO]File.pm [.lib.IO]Handle.pm [.lib.IO]Pipe.pm [.lib.IO]Seekable.pm [.lib.IO]Socket.pm [.lib.auto.IO]IO$(E)
  	@ $(NOOP)
  
  [.lib]IO.pm : [.ext.IO]Descrip.MMS
  	@ If F$Search("[.lib]auto.dir").eqs."" Then Create/Directory [.lib.auto]
  	@ Set Default [.ext.IO]
--- 538,562 -----
  THREAD : [.lib]THREAD.pm [.lib.auto.THREAD]THREAD$(E)
  	@ $(NOOP)
  
+ [.lib]THREAD.pm : [.ext.THREAD]Descrip.MMS
+ 	@ If F$Search("[.lib]auto.dir").eqs."" Then Create/Directory [.lib.auto]
+ 	@ Set Default [.ext.THREAD]
+ 	$(MMS)
+ 	@ Set Default [--]
+ 
+ [.lib.auto.THREAD]THREAD$(E) : [.ext.THREAD]Descrip.MMS
+ 	@ Set Default [.ext.THREAD]
+ 	$(MMS)
+ 	@ Set Default [--]
+ 
+ # Add "-I[--.lib]" t $(MINIPERL) so we use this copy of lib after C<chdir>
+ # ${@} necessary to distract different versions of MM[SK]/make
+ [.ext.THREAD]Descrip.MMS : [.ext.THREAD]Makefile.PL $(LIBPREREQ) $(DBG)perlshr$(E)
+ 	$(MINIPERL) "-I[--.lib]" -e "chdir('[.ext.THREAD]') or die $!; do 'Makefile.PL'; print ${@} if ${@};" "INST_LIB=[--.lib]" "INST_ARCHLIB=[--.lib]"
+ 
+ IO : [.lib]IO.pm [.lib.IO]File.pm [.lib.IO]Handle.pm [.lib.IO]Pipe.pm [.lib.IO]Seekable.pm [.lib.IO]Socket.pm [.lib.auto.IO]IO$(E)
+ 	@ $(NOOP)
+ 
  [.lib]IO.pm : [.ext.IO]Descrip.MMS
  	@ If F$Search("[.lib]auto.dir").eqs."" Then Create/Directory [.lib.auto]
  	@ Set Default [.ext.IO]
**************
*** 1783,1788
  	Set Default [.ext.Opcode]
  	- $(MMS) realclean
  	Set Default [--]
  .ifdef DECC
  	Set Default [.ext.POSIX]
  	- $(MMS) realclean
--- 1852,1865 -----
  	Set Default [.ext.Opcode]
  	- $(MMS) realclean
  	Set Default [--]
+ 	Set Default [.ext.Attrs]
+ 	- $(MMS) realclean
+ 	Set Default [--]
+ .ifdef THREAD
+ 	Set Default [.ext.Thread]
+ 	- $(MMS) realclean
+ 	Set Default [--]
+ .endif
  .ifdef DECC
  	Set Default [.ext.POSIX]
  	- $(MMS) realclean


Index: vms/gen_shrfls.pl
**************
*** 150,155
    $line =~ s/\[.*//;
    $line =~ s/=.*//;
    $line =~ s/\W*;?\s*$//;
    print "\tfiltered to \\$line\\\n" if $debug > 1;
    if ($line =~ /(\w+)$/) {
      print "\tvar name is \\$1\\" . ($const ? ' (const)' : '') . "\n" if $debug > 1;
--- 150,156 -----
    $line =~ s/\[.*//;
    $line =~ s/=.*//;
    $line =~ s/\W*;?\s*$//;
+   $line =~ s/\(void//;
    print "\tfiltered to \\$line\\\n" if $debug > 1;
    if ($line =~ /(\w+)$/) {
      print "\tvar name is \\$1\\" . ($const ? ' (const)' : '') . "\n" if $debug > 1;


Index: vms/vms.c
**************
*** 3179,3184
  /*}}}*/
  
  #if __VMS_VER < 70000000 || __DECC_VER < 50200000
  /* Used for UTC calculation in my_gmtime(), my_localtime(), my_time(),
   * my_utime(), and flex_stat(), all of which operate on UTC unless
   * VMSISH_TIMES is true.
--- 3179,3257 -----
  /*}}}*/
  
  #if __VMS_VER < 70000000 || __DECC_VER < 50200000
+ /* Signal handling routines, pulled into the core from Posix.xs.
+  *
+  * We need these for threads, so they've been rolled into the core,
+  * rather than left in POSIX.XS.
+  *
+  * (DRS, Oct 23, 1997)
+  */
+ 
+ /* sigset_t is atomic under VMS, so these routines are easy */
+ int my_sigemptyset(sigset_t *set) {
+   if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
+   *set = 0; return 0;
+ }
+ int my_sigfillset(sigset_t *set) {
+   int i;
+   if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
+   for (i = 0; i < NSIG; i++) *set |= (1 << i);
+   return 0;
+ }
+ int my_sigaddset(sigset_t *set, int sig) {
+   if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
+   if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
+   *set |= (1 << (sig - 1));
+   return 0;
+ }
+ int my_sigdelset(sigset_t *set, int sig) {
+   if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
+   if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
+   *set &= ~(1 << (sig - 1));
+   return 0;
+ }
+ int my_sigismember(sigset_t *set, int sig) {
+   if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
+   if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
+   *set & (1 << (sig - 1));
+ }
+ int my_sigprocmask(int how, sigset_t *set, sigset_t *oset) {
+   sigset_t tempmask;
+ 
+   /* If set and oset are both null, then things are badky wrong. Bail */
+   if ((oset == NULL) && (set == NULL)) {
+     set_errno(EFAULT); set_vaxc_errno(SS$_ACCVIO);
+     return -1;
+   }
+ 
+   /* If set's null, then we're just handling a fetch. */
+   if (set == NULL) {
+     tempmask = sigblock(0);
+   } else {
+     switch (how) {
+     case SIG_SETMASK:
+       tempmask = sigsetmask(*set);
+       break;
+     case SIG_BLOCK:
+       tempmask = sigblock(*set);
+       break;
+     case SIG_UNBLOCK:
+       tempmask = sigblock(0);
+       sigsetmask(*oset & ~tempmask);
+       break;
+     default:
+       set_errno(EINVAL); set_vaxc_errno(LIB$_INVARG);
+       return -1;
+     }
+   }
+ 
+   /* Did they pass us an oset? If so, stick our holding mask into it */
+   if (oset)
+     *oset = tempmask;
+   
+   return 0;
+ }
+ 
  /* Used for UTC calculation in my_gmtime(), my_localtime(), my_time(),
   * my_utime(), and flex_stat(), all of which operate on UTC unless
   * VMSISH_TIMES is true.


Index: vms/vmsish.h
**************
*** 115,120
  #  define my_gmtime		Perl_my_gmtime
  #  define my_localtime		Perl_my_localtime
  #  define my_time		Perl_my_time
  #endif
  #  define cando_by_name		Perl_cando_by_name
  #  define flex_fstat		Perl_flex_fstat
--- 115,126 -----
  #  define my_gmtime		Perl_my_gmtime
  #  define my_localtime		Perl_my_localtime
  #  define my_time		Perl_my_time
+ #  define my_sigemptyset        Perl_my_sigemptyset
+ #  define my_sigfillset         Perl_my_sigfillset
+ #  define my_sigaddset          Perl_my_sigaddset
+ #  define my_sigdelset          Perl_my_sigdelset
+ #  define my_sigismember        Perl_my_sigismember
+ #  define my_sigprocmask        Perl_my_sigprocmask
  #endif
  #  define cando_by_name		Perl_cando_by_name
  #  define flex_fstat		Perl_flex_fstat
**************
*** 336,341
  #define gmtime(t) my_gmtime(t)
  #define localtime(t) my_localtime(t)
  #define time(t) my_time(t)
  #endif
  
  /* VMS doesn't use a real sys_nerr, but we need this when scanning for error
--- 342,370 -----
  #define gmtime(t) my_gmtime(t)
  #define localtime(t) my_localtime(t)
  #define time(t) my_time(t)
+ #define sigemptyset(t) my_sigemptyset(t)
+ #define sigfillset(t) my_sigfillset(t)
+ #define sigaddset(t, u) my_sigaddset(t, u)
+ #define sigdelset(t, u) my_sigdelset(t, u)
+ #define sigismember(t, u) my_sigismember(t, u)
+ #define sigprocmask(t, u, v) my_sigprocmask(t, u, v)
+ typedef int sigset_t;
+ /* The tools for sigprocmask() are there, just not the routine itself */
+ #    ifndef SIG_UNBLOCK
+ #      define SIG_UNBLOCK 1
+ #    endif
+ #    ifndef SIG_BLOCK
+ #      define SIG_BLOCK 2
+ #    endif
+ #    ifndef SIG_SETMASK
+ #      define SIG_SETMASK 3
+ #    endif
+ #    define sigaction sigvec
+ #    define sa_flags sv_onstack
+ #    define sa_handler sv_handler
+ #    define sa_mask sv_mask
+ #    define sigsuspend(set) sigpause(*set)
+ #    define sigpending(a) (not_here("sigpending"),0)
  #endif
  
  /* VMS doesn't use a real sys_nerr, but we need this when scanning for error
**************
*** 541,546
  struct tm *	my_localtime _((const time_t *));
  time_t	my_time _((time_t *));
  #endif /* We're assuming these three come as a package */
  I32	cando_by_name _((I32, I32, char *));
  int	flex_fstat _((int, struct mystat *));
  int	flex_stat _((char *, struct mystat *));
--- 570,585 -----
  struct tm *	my_localtime _((const time_t *));
  time_t	my_time _((time_t *));
  #endif /* We're assuming these three come as a package */
+ /* We're just gonna assume that if we've got an antique here that we */
+ /* need the signal functions */
+ #if __VMS_VER < 70000000 || __DECC_VER < 50200000
+ int     my_sigemptyset _((sigset_t *));
+ int     my_sigfillset  _((sigset_t *));
+ int     my_sigaddset   _((sigset_t *, int));
+ int     my_sigdelset   _((sigset_t *, int));
+ int     my_sigismember _((sigset_t *, int));
+ int     my_sigprocmask _((int, sigset_t *, sigset_t *));
+ #endif
  I32	cando_by_name _((I32, I32, char *));
  int	flex_fstat _((int, struct mystat *));
  int	flex_stat _((char *, struct mystat *));


Index: ext/posix/posix.xs
**************
*** 58,133
  #if ((__VMS_VER >= 70000000) && (__DECC_VER >= 50200000)) || (__CRTL_VER >= 70000000)
  #    define HAS_TZNAME  /* shows up in VMS 7.0 or Dec C 5.6 */
  #    include <utsname.h>
- #else
-      /* The default VMS emulation of Unix signals isn't very POSIXish */
-      typedef int sigset_t;
- #    define sigpending(a) (not_here("sigpending"),0)
- 
-      /* sigset_t is atomic under VMS, so these routines are easy */
-      int sigemptyset(sigset_t *set) {
- 	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
- 	*set = 0; return 0;
-      }
-      int sigfillset(sigset_t *set) {
- 	int i;
- 	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
- 	for (i = 0; i < NSIG; i++) *set |= (1 << i);
- 	return 0;
-      }
-      int sigaddset(sigset_t *set, int sig) {
- 	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
- 	if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
- 	*set |= (1 << (sig - 1));
- 	return 0;
-      }
-      int sigdelset(sigset_t *set, int sig) {
- 	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
- 	if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
- 	*set &= ~(1 << (sig - 1));
- 	return 0;
-      }
-      int sigismember(sigset_t *set, int sig) {
- 	if (!set) { SETERRNO(EFAULT,SS$_ACCVIO); return -1; }
- 	if (sig > NSIG) { SETERRNO(EINVAL,LIB$_INVARG); return -1; }
- 	*set & (1 << (sig - 1));
-      }
-      /* The tools for sigprocmask() are there, just not the routine itself */
- #    ifndef SIG_UNBLOCK
- #      define SIG_UNBLOCK 1
- #    endif
- #    ifndef SIG_BLOCK
- #      define SIG_BLOCK 2
- #    endif
- #    ifndef SIG_SETMASK
- #      define SIG_SETMASK 3
- #    endif
-      int sigprocmask(int how, sigset_t *set, sigset_t *oset) {
- 	if (!set || !oset) {
- 	  set_errno(EFAULT); set_vaxc_errno(SS$_ACCVIO);
- 	  return -1;
- 	}
- 	switch (how) {
- 	  case SIG_SETMASK:
- 	    *oset = sigsetmask(*set);
- 	    break;
- 	  case SIG_BLOCK:
- 	    *oset = sigblock(*set);
- 	    break;
- 	  case SIG_UNBLOCK:
- 	    *oset = sigblock(0);
- 	    sigsetmask(*oset & ~*set);
- 	    break;
- 	  default:
- 	    set_errno(EINVAL); set_vaxc_errno(LIB$_INVARG);
- 	    return -1;
- 	}
- 	return 0;
-      }
- #    define sigaction sigvec
- #    define sa_flags sv_onstack
- #    define sa_handler sv_handler
- #    define sa_mask sv_mask
- #    define sigsuspend(set) sigpause(*set)
  #  endif /* __VMS_VER >= 70000000 or Dec C 5.6 */
  
     /* The POSIX notion of ttyname() is better served by getname() under VMS */
--- 58,63 -----
  #if ((__VMS_VER >= 70000000) && (__DECC_VER >= 50200000)) || (__CRTL_VER >= 70000000)
  #    define HAS_TZNAME  /* shows up in VMS 7.0 or Dec C 5.6 */
  #    include <utsname.h>
  #  endif /* __VMS_VER >= 70000000 or Dec C 5.6 */
  
     /* The POSIX notion of ttyname() is better served by getname() under VMS */

